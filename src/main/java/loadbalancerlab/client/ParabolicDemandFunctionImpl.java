package loadbalancerlab.client;

/**
 * Sleeps the thread for a specified amount of time.
 * Implementation of DemandFunction interface.
 * A downward opening parabolic demand function.
 */
public class ParabolicDemandFunctionImpl implements DemandFunction {
    /**
     * How long the function runs (in milliseconds).
     */
    private int runningTime;

    /**
     * The start time for the function when the demand starts to increase (seconds since 1-Jan-1970).
     */
    private int startTime;

    /**
     * The rest interval at peak demand (in milliseconds).
     */
    private int minRestInterval;

    /**
     * The rest interval at minimum demand (in milliseconds).
     */
    private int maxRestInterval;

    /**
     * Coefficient which controls shape of demand parabola.
     */
    private double coeff;

    /**
     * Value which represents the peak demand generated by a Client, calculated as 1 / sleep time in seconds.
     */
    private double maxDemand;

    /**
     * Value which represents the minimum demand generated by a Client, calculated as 1 / sleep time in seconds.
     */

    private double minDemand;

    /**
     * Constructor
     * @param runningTime           How long the function runs (in seconds).
     * @param startTime             The start time for the function when the demand starts to increase
     *                              (seconds since 1-Jan-1970).
     * @param minRestInterval       The rest interval at peak demand (in milliseconds).
     * @param maxRestInterval       The rest interval at minimum demand (in milliseconds).
     */
    public ParabolicDemandFunctionImpl( int runningTime, int startTime, int minRestInterval, int maxRestInterval ) {
        this.runningTime = runningTime;
        this.startTime = startTime;
        this.minRestInterval = minRestInterval;
        this.maxRestInterval = maxRestInterval;
        minDemand = 1 / (maxRestInterval / 1_000.0d);
        maxDemand = 1 / (minRestInterval / 1_000.0d);

        coeff = (maxDemand - minDemand) / Math.pow(((double)runningTime) / 2.0d, 2.0d);
    }

    @Override
    public void rest() throws InterruptedException {
        int currentTime = (int)(System.currentTimeMillis() / 1_000);
        int sleepInterval;

        if (currentTime < startTime || currentTime > (startTime + runningTime)) {

            /* If time is before the start time and after the end time, return the sleep interval which simulates
               minimum demand. */
            sleepInterval = maxRestInterval;
        } else {
            double currentDemand = -coeff * Math.pow(currentTime - (startTime + runningTime / 2), 2) + maxDemand;
            sleepInterval = (int)((1 / currentDemand) * 1_000);
        }

        Thread.sleep(sleepInterval);
    }
}
